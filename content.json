{"meta":{"title":"爱学习的大太阳","subtitle":null,"description":null,"author":"大太阳","url":"http://wudiblog.com"},"pages":[{"title":"关于","date":"2020-05-27T06:08:40.423Z","updated":"2019-02-02T07:54:35.719Z","comments":false,"path":"about/index.html","permalink":"http://wudiblog.com/about/index.html","excerpt":"","text":"只想安安心心写代码，关于自己什么也不想说"},{"title":"书单","date":"2020-05-27T06:08:40.423Z","updated":"2019-02-01T09:26:45.000Z","comments":false,"path":"books/index.html","permalink":"http://wudiblog.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-05-27T06:08:40.424Z","updated":"2019-02-01T09:49:47.000Z","comments":false,"path":"links/index.html","permalink":"http://wudiblog.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-27T06:08:40.424Z","updated":"2019-02-01T07:25:31.000Z","comments":false,"path":"categories/index.html","permalink":"http://wudiblog.com/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-05-27T06:08:40.424Z","updated":"2019-02-01T07:25:31.000Z","comments":false,"path":"/404.html","permalink":"http://wudiblog.com//404.html","excerpt":"","text":""},{"title":"仓库","date":"2020-05-27T06:08:40.416Z","updated":"2019-02-03T04:37:20.577Z","comments":false,"path":"repository/index.html","permalink":"http://wudiblog.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-27T06:08:40.424Z","updated":"2019-02-01T07:25:31.000Z","comments":false,"path":"tags/index.html","permalink":"http://wudiblog.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【性能优化】启动优化实践","slug":"【性能优化】启动优化实践","date":"2020-06-03T02:22:00.000Z","updated":"2020-06-03T07:58:40.016Z","comments":true,"path":"2020/06/03/【性能优化】启动优化实践/","link":"","permalink":"http://wudiblog.com/2020/06/03/【性能优化】启动优化实践/","excerpt":"","text":"在Android当中启动优化至关重要，用以给用户良好的体验，避免用户一安装应用就卸载 启动的分类 冷启动 冷启动是指APP在手机启动后第一次运行，或者APP进程被kill掉后在再次启动。 冷启动的必要条件是该APP进程不存在，这就意味着系统需要创建进程，APP需要初始化。在这三种启动方式中，冷启动耗时最长，对于冷启动的优化也是最具挑战的。因此本文重点谈论的是对冷启动相关的优化。 热启动 App进程存在，并且Activity对象仍然存在内存中没有被回收。可以重复避免对象初始化，布局解析绘制。 场景就类似你打开微信聊了一会天这时候出去看了下日历 在打开微信 微信这时候启动就属于热启动。 温启动 App进程存在，当时Activity可能因为内存不足被回收。这时候启动App不需要重新创建进程，但是Activity的onCrate还是需要重新执行的。 场景类似打开淘宝逛了一圈然后切到微信去聊天去了，过了半小时再次回到淘宝。这时候淘宝的进程存在，但是Activity可能被回收，这时候只需要重新加载Activity即可。 启动的过程 ​ 当点击APP的启动图标时，安卓系统会从Zygote进程中fork创建出一个新的进程分配给该应用，之后会依次创建和初始化Application类，创建MainActivity类，加载主题样式中的windowBackground等属性设置给MainActivity以及配置Activity层级上的一些属性，再inflate布局，当onCreate/onStart/onResume方法都走完了后最后才执行contentView的measure/layout/draw显示在界面上 ​ 总结下来就是 1Application的构造器方法--&gt;attchBaseContext()--&gt;onCreate()--&gt;Activity的构造方法--&gt;onCreate()--&gt;配置主题中背景属性--&gt;onStart()--&gt;onResume()--&gt;测量布局绘制显示在界面上 这里很明显有两个优化点： Application OnCrate()优化 当APP启动时，空白的启动窗口将保留在屏幕上，直到系统首次完成绘制应用程序。此时，系统进程会交换应用程序的启动窗口，允许用户开始与应用程序进行交互。如果应用程序中重载了Application.onCreate()，系统会调用onCreate()方法。之后，应用程序会生成主线程（也称为UI线程），并通过创建MainActivity来执行任务。 通常会在这里做大量的通用组件的初始化操作； 建议：很多第三方SDK都放在Application初始化，我们可以放到用到的地方才进行初始化操作。 Activity onCreate()优化 Activity的onCreate流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题； 建议：Activity仅初始化那些立即需要的对象，xml布局减少冗余或嵌套布局。 启动的优化 如何量化 目前为止见过最最牛逼的是使用机械手和高速相机测试，手机开机后使用机械手点击应用桌面图标，高速相机记录启动过程，后续通过程序分析视频，从机械手点击图标到Activity显示出来使用了多少时间。这种方式是最直观和精确的，但是成本也很高。 通过shell 命令 12345adb shell am start -W [packageName]/[packageName.MainActivity]执行成功后将返回三个测量到的时间：ThisTime:一般和TotalTime时间一样，除非在应用启动时开了一个透明的Activity预先处理一些事再显示出主Activity，这样将比TotalTime小。TotalTime:应用的启动时间，包括创建进程+Application初始化+Activity初始化到界面显示。WaitTime:一般比TotalTime大点，包括系统影响的耗时。 可以通过在代码中增加log来计算启动时间 使用systrace，trace工具使用单独来记录 优化策略 1231.利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；2.避免在启动时做密集沉重的初始化（Heavy app initialization）；3.定位问题：避免I/O操作、反序列化、网络操作、布局嵌套等。 1. 启动加速之主题切换 定义一个style： 1234&lt;style name=\"AppTheme.Launcher\"&gt; &lt;!--关闭启动窗口--&gt; &lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;&lt;/style&gt; 只需要再启动页面引用： 123456789&lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme.Launcher\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 最后在MainActivity恢复正常主题： 12345678public class MainActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setTheme(R.style.AppTheme); setContentView(R.layout.activity_main); &#125;&#125; 这样启动APP，就没有白屏，但会出现点击桌面图标而半天没有反应的现象，显然不好，很多APP把这个闪屏当做一个广告、品牌宣传的页面。 来看看如何使用drawable方式实现的，修改之前的style： 123&lt;style name=\"AppTheme.Launcher\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/branded_launch_screens&lt;/item&gt;&lt;/style&gt; drawable/branded_launch_screens: 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:opacity=\"opaque\"&gt; &lt;!--黑色背景颜色--&gt; &lt;item android:drawable=\"@android:color/black\" /&gt; &lt;!-- 产品logo--&gt; &lt;item&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@mipmap/empty_image01\" /&gt; &lt;/item&gt; &lt;!-- 右上角的图标元素 --&gt; &lt;item&gt; &lt;bitmap android:gravity=\"top|right\" android:src=\"@mipmap/github\" /&gt; &lt;/item&gt; &lt;!--最下面的文字--&gt; &lt;item android:bottom=\"50dp\"&gt; &lt;bitmap android:gravity=\"bottom\" android:src=\"@mipmap/ic_launcher\" /&gt; &lt;/item&gt;&lt;/layer-list&gt; 其中android:opacity=”opaque”参数是为了防止在启动的时候出现背景的闪烁。 如果不用drawable的方式实现，直接将背景设置为一张图片也是可以的，更加简单，也更为合适 1234&lt;style name=\"AppTheme.Launcher\"&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@mipmap/app_welcome&lt;/item&gt;&lt;/style&gt; 最终：在启动的时候，会先展示一个界面，这个界面就是Manifest中设置的Style，等Activity加载完毕后，再去加载Activity的界面，而在Activity的界面中，我们将主题重新设置为正常的主题，从而产生一种快的感觉。不过如上文总结这种方式其实并没有真正的加速启动过程，而是通过交互体验来优化了展示的效果。 2. 启动加速之避免过多的初始化操作 在Application以及首屏Activity中我们主要做了下面这些事： 2.1 MultiDex初始化 ​ 但是在Dalvik下MultiDex有个问题：5.0以下某些低端机会出现ANR或者长时间卡顿不进入引导页，而罪魁祸首是MultiDex.install(Context context)的dexopt过程耗时过长。因此需要在初次启动时做特别处理。 ​ 而5.0以上会使用ART，在ART下MultiDex是不存在这个问题的，这主要是因为ART下采用Ahead-of-time (AOT) compilation技术，系统在APK的安装过程中会使用自带的dex2oat工具对APK中可用的DEX文件进行编译并生成一个可在本地机器上运行的文件，这样能提高应用的启动速度，只是在安装过程中进行了处理这样会影响应用的安装速度。 解决方案 1231、在Application.attachBaseContext(Context base)中，判断是否初次启动，以及系统版本是否小于5.0，如果是，跳到2；否则，直接执行MultiDex.install(Context context)。2、开启一个新进程，在这个进程中执行MultiDex.install(Context context)。执行完毕，唤醒主进程，自身结束。主进程在开启新进程后，自身是挂起的，直到被唤醒。3、唤醒的主进程继续执行初始化操作。 2.2 Application中主要做了各种三方组件的初始化 对于过多的初始化任务,我们考虑以下优化方案: 考虑异步初始化三方组件，不阻塞主线程，实际上我们粗粒度的把所有三方组件都放到异步任务里，可能会出现WorkThread中尚未初始化完毕但MainThread中已经使用的错误，因此这种情况建议延迟到使用前再去初始化； 三方SDK改为懒加载，不在Application OnCreate()时初始化，在真正用到的时候再去加载。 当首页面打开完成后，发送消息通知初始化操作，与第一点相似，适用于MainThread在启动打开页面过程中不用到的初始化 异步 12345678910public static void initThirdService() &#123; new Thread()&#123; @Override public void run() &#123; super.run(); //;初始化第三方库 &#125; &#125;.start();&#125; 懒加载 原本： 12345678910public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); ImageLoaderConfiguration.Builder config = new ImageLoaderConfiguration.Builder(this); ImageLoader.getInstance().init(config.build()); &#125;&#125; 123456Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.luozhanwei.myapplication/.MainActivity &#125;Status: okActivity: com.luozhanwei.myapplication/.MainActivityThisTime: 423TotalTime: 423WaitTime: 441 改为封装了一个懒加载ImageLoader的工具类示例 1234567891011121314151617181920212223242526public class ImageUtil &#123; private static boolean sInit; private synchronized static void ensureInit() &#123; if (sInit) &#123; return; &#125; ImageLoaderConfiguration.Builder config = new ImageLoaderConfiguration.Builder(SecurityCoreApplication.getInstance()); .... // Initialize ImageLoader with configuration. ImageLoader.getInstance().init(config.build()); sInit = true; &#125;public static void display(String uri, ImageView imageView, boolean cacheOnDisk) &#123; imageView.setImageResource(R.drawable.icon_app_default); ensureInit(); ImageLoader loader = ImageLoader.getInstance(); if (cacheOnDisk) &#123; loader.displayImage(uri, imageView); &#125; else &#123; loader.displayImage(uri, imageView, OPTIONS_NO_CACHE_DISK); &#125; &#125; 123456Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.luozhanwei.myapplication/.MainActivity &#125;Status: okActivity: com.luozhanwei.myapplication/.MainActivityThisTime: 389TotalTime: 389WaitTime: 405 可以看到TotalTime比之前减少了34ms（给出的数据为10次检测平均值）。 3.启动加速之定位问题 启动应用，点击 Start Method Tracing，应用启动后再次点击，会自动打开刚才操作所记录下的.trace文件，建议使用DDMS来查看，功能更加方便全面。 总结 利用主题快速显示界面； 异步初始化组件； 梳理业务逻辑，延迟初始化组件、操作； 去掉无用代码、重复逻辑等。 优化MainActivity的布局结构 其他内容 在最近任务给App加锁 某些厂商为了用户体验提供了给APP上锁的功能，目的就是让用户自己做主是上锁的APP不被杀，启动的时候不会处于冷启动方式，但是加锁也不是万能的,Low memory killer在内存极度吃紧的情况下也会杀死加锁APP,在此启动时也将以冷启动方式运行。 AI和启动方式有什么关系 AI在进程管理方面的应用。MIUI10发布了进程AI唤醒功能，是APP启动速度远超友商。这其中的道理简单说就是学习用户的使用习惯，提前将App进程创建好，当用户打开APP时不会出去冷启动。比如你是微信重度用户你发现用了MIUI10就再也见不到微信启动页面的那个地球了，这就是AI唤醒的功劳。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://wudiblog.com/categories/移动端/"}],"tags":[{"name":"-性能优化 -Android","slug":"性能优化-Android","permalink":"http://wudiblog.com/tags/性能优化-Android/"}]},{"title":"view与activity生命周期的关系","slug":"view绘制与activity生命周期的关系","date":"2020-06-02T04:22:00.000Z","updated":"2020-06-03T03:25:21.032Z","comments":true,"path":"2020/06/02/view绘制与activity生命周期的关系/","link":"","permalink":"http://wudiblog.com/2020/06/02/view绘制与activity生命周期的关系/","excerpt":"","text":"View依附于Activity，学习View与Activity生命周期之间的关系，可以更好的理解View的工作原理 View的所有生命周期 onFinishInflate() 当View中所有的子控件均被映射成xml后触发 onMeasure(int, int) 确定所有子元素的大小 onLayout(boolean, int, int, int, int) 当View分配所有的子元素的大小和位置时触发 onSizeChanged(int, int, int, int) 当view的大小发生变化时触发 onDraw(Canvas) view渲染内容的细节 onKeyDown(int, KeyEvent) 有按键按下后触发 onKeyUp(int, KeyEvent) 有按键按下后弹起时触发 onTrackballEvent(MotionEvent) 轨迹球事件 onTouchEvent(MotionEvent) 触屏事件 onFocusChanged(boolean, int, Rect) 当View获取或失去焦点时触发 onWindowFocusChanged(boolean) 当窗口包含的view获取或失去焦点时触发 onAttachedToWindow() 当view被附着到一个窗口时触发 onDetachedFromWindow() 当view离开附着的窗口时触发，Android123提示该方法和 onAttachedToWindow() 是相反的 onWindowVisibilityChanged(int) 当窗口中包含的可见的view发生变化时触发 View的关键生命周期 –&gt; 构造View() –&gt; onFinishInflate() –&gt; onAttachedToWindow() –&gt; onMeasure() –&gt; onSizeChanged() –&gt; onLayout() –&gt; onDraw() –&gt; onWindowFocusChanged() –&gt; onDetackedFromWindow() View与Activity生命周期 (1) 在Activity onCreate方法中初始化了View , 调用了View 的onFinishInflate (2) 在执行完 Activity的 onPostResume方法之后(第一次onResume之后)才真正开始了View的绘制工作： onAttachedToWindow –&gt; onMeasure –&gt; onSizeChanged –&gt; onLayout –&gt; onDraw 当按住锁屏键的时候，Activity和View生命周期发生变化： Activity onPause之后 调用了 View的 onSaveInstanceState方法 当重新回到页面的时候，Activity和View的生命周变化： 重新回到页View的生命周期方法没有被调用 当点击回退的时候，Activity和View的生命周期发生变化： 点击回退Activity onPause -&gt; onStop -&gt; onDestroy，onDestroy之后 调用了 View的onDetachedFromWindow方法 总结 (1) 在Activity onCreate方法中初始化了View 的时候, 调用了View 的onFinishInflate (2) 在执行完 Activity的 onResume 方法之后，才真正开始了View的绘制工作：onMeasure –&gt; onSizeChanged –&gt; onLayout –&gt; onDraw (3) onMeasure,onSizeChanged,onLayout,onDraw可能由于setVisible或onResume调用多次，而onAttachedToWindow与onDetachedFromWindow在创建与销毁view的过程中只会调用一次","categories":[{"name":"移动端","slug":"移动端","permalink":"http://wudiblog.com/categories/移动端/"}],"tags":[{"name":"-View -Android","slug":"View-Android","permalink":"http://wudiblog.com/tags/View-Android/"}]},{"title":"【算法】6.Z 字形变换","slug":"【算法】6.Z 字形变换","date":"2020-05-28T06:10:22.000Z","updated":"2020-06-03T02:28:18.430Z","comments":true,"path":"2020/05/28/【算法】6.Z 字形变换/","link":"","permalink":"http://wudiblog.com/2020/05/28/【算法】6.Z 字形变换/","excerpt":"","text":"将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1: 12输入: s = \"LEETCODEISHIRING\", numRows = 3输出: \"LCIRETOESIIGEDHN\" 示例 2: 123456789输入: s = \"LEETCODEISHIRING\", numRows = 4输出: \"LDREOEIIECIHNTSG\" 解释:L D RE O E I IE C I H NT S G 题解： 12345678910111213141516class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows &lt; 2) return s; List&lt;StringBuilder&gt; rows = new ArrayList&lt;StringBuilder&gt;(); for(int i = 0; i &lt; numRows; i++) rows.add(new StringBuilder()); int i = 0, flag = -1; for(char c : s.toCharArray()) &#123; rows.get(i).append(c); if(i == 0 || i == numRows -1) flag = - flag; i += flag; &#125; StringBuilder res = new StringBuilder(); for(StringBuilder row : rows) res.append(row); return res.toString(); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/tags/算法/"}]},{"title":"【算法】5.最长回文子串","slug":"【算法】5.最长回文子串","date":"2020-05-27T03:10:22.000Z","updated":"2020-05-28T11:54:06.566Z","comments":true,"path":"2020/05/27/【算法】5.最长回文子串/","link":"","permalink":"http://wudiblog.com/2020/05/27/【算法】5.最长回文子串/","excerpt":"","text":"给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1: 123输入: \"babad\"输出: \"bab\"注意: \"aba\" 也是一个有效答案。 示例 2: 12输入: \"cbbd\"输出: \"bb\" 题解： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public String longestPalindrome(String s) &#123; // 特判 int len = s.length(); if (len &lt; 2) &#123; return s; &#125; int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i, j] 是否是回文串 boolean[][] dp = new boolean[len][len]; char[] charArray = s.toCharArray(); for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = true; &#125; for (int j = 1; j &lt; len; j++) &#123; for (int i = 0; i &lt; j; i++) &#123; if (charArray[i] != charArray[j]) &#123; dp[i][j] = false; &#125; else &#123; if (j - i &lt; 3) &#123; dp[i][j] = true; &#125; else &#123; dp[i][j] = dp[i + 1][j - 1]; &#125; &#125; // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置 if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123; maxLen = j - i + 1; begin = i; &#125; &#125; &#125; return s.substring(begin, begin + maxLen); &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/tags/算法/"}]},{"title":"【算法】1.两数相加","slug":"【算法】1.两数相加","date":"2020-05-27T03:10:22.000Z","updated":"2020-05-28T06:20:41.878Z","comments":true,"path":"2020/05/27/【算法】1.两数相加/","link":"","permalink":"http://wudiblog.com/2020/05/27/【算法】1.两数相加/","excerpt":"","text":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 题解： 12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/tags/算法/"}]},{"title":"【算法】4.寻找两个正序数组的中位数","slug":"【算法】4.寻找两个正序数组的中位数","date":"2020-05-27T03:10:22.000Z","updated":"2020-05-28T06:20:59.469Z","comments":true,"path":"2020/05/27/【算法】4.寻找两个正序数组的中位数/","link":"","permalink":"http://wudiblog.com/2020/05/27/【算法】4.寻找两个正序数组的中位数/","excerpt":"","text":"给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2: 1234nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 题解： 12345678910111213141516171819202122232425262728293031323334353637public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (nums1.length &gt; nums2.length) &#123; return findMedianSortedArrays(nums2, nums1); &#125; int m = nums1.length; int n = nums2.length; int left = 0, right = m, ansi = -1; // median1：前一部分的最大值 // median2：后一部分的最小值 int median1 = 0, median2 = 0; while (left &lt;= right) &#123; // 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1] // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1] int i = (left + right) / 2; int j = (m + n + 1) / 2 - i; // nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j] int nums_im1 = (i == 0 ? Integer.MIN_VALUE : nums1[i - 1]); int nums_i = (i == m ? Integer.MAX_VALUE : nums1[i]); int nums_jm1 = (j == 0 ? Integer.MIN_VALUE : nums2[j - 1]); int nums_j = (j == n ? Integer.MAX_VALUE : nums2[j]); if (nums_im1 &lt;= nums_j) &#123; ansi = i; median1 = Math.max(nums_im1, nums_jm1); median2 = Math.min(nums_i, nums_j); left = i + 1; &#125; else &#123; right = i - 1; &#125; &#125; return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/tags/算法/"}]},{"title":"【算法】3.无重复字符的最长子串","slug":"【算法】3.无重复字符的最长子串","date":"2020-05-27T03:10:22.000Z","updated":"2020-05-28T06:20:54.217Z","comments":true,"path":"2020/05/27/【算法】3.无重复字符的最长子串/","link":"","permalink":"http://wudiblog.com/2020/05/27/【算法】3.无重复字符的最长子串/","excerpt":"","text":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 123输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 1234输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 题解： 123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int end = 0, start = 0; end &lt; n; end++) &#123; char alpha = s.charAt(end); if (map.containsKey(alpha)) &#123; start = Math.max(map.get(alpha), start); &#125; ans = Math.max(ans, end - start + 1); map.put(s.charAt(end), end + 1); &#125; return ans; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/tags/算法/"}]},{"title":"【算法】2.两数之和","slug":"【算法】2.两数之和","date":"2020-05-27T03:10:22.000Z","updated":"2020-05-28T06:20:48.072Z","comments":true,"path":"2020/05/27/【算法】2.两数之和/","link":"","permalink":"http://wudiblog.com/2020/05/27/【算法】2.两数之和/","excerpt":"","text":"给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例： 123给定 nums = [2,7,11,15]，target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0,1] 题解： 1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wudiblog.com/tags/算法/"}]},{"title":"18年公司年会","slug":"18年公司年会","date":"2019-01-29T08:27:03.000Z","updated":"2019-02-02T08:30:36.896Z","comments":true,"path":"2019/01/29/18年公司年会/","link":"","permalink":"http://wudiblog.com/2019/01/29/18年公司年会/","excerpt":"","text":"万年不中奖的体质决定了抽奖环节我只能干看着… 部门获奖，今年团队的努力得到了肯定，来年继续加油！","categories":[{"name":"工作","slug":"工作","permalink":"http://wudiblog.com/categories/工作/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://wudiblog.com/tags/工作/"}]},{"title":"「借鉴」基于多列卷积神经网络的单图像人群计数","slug":"基于多列卷积神经网络的单图像人群计数","date":"2019-01-10T08:39:55.000Z","updated":"2019-02-02T08:57:17.112Z","comments":true,"path":"2019/01/10/基于多列卷积神经网络的单图像人群计数/","link":"","permalink":"http://wudiblog.com/2019/01/10/基于多列卷积神经网络的单图像人群计数/","excerpt":"","text":"核心实验 手动提取特征回归人数 a) 解决人群计数问题的传统的做法是手动设计并提取各种特征(Hand-craftedFeatures)，然后再基于这些特征训练一个线性或非线性函数来回归人头数。此类 算法大多三个步骤: 1)前景分割;2)特征提取;3)人数回归。接下来将对这三个步骤分别做介绍。 ​ i. 前景分割 前景(人群)分割的目的是将人群从图像中分割出来便于后面的特征提取， 分割性能的好坏直接关系的最终的计数精度，因此这是限制传统算法性能的一个 重要因素。常用的分割算法有:光流法(Optical Flow)、混合动态纹理(Mixture of Dynamic Textures)、小波分析(Wavelets) 等。 ​ ii. 特征提取 在完成前景分割之后，紧接着就是从分割得到的前景(人群)提取各种不同 的低层特征(Low-level Features)，常用的特征有:人群面积和周长(Area and Perimeter of Crowd Mask)、边的数量(Edge Count)、边的方向(Edge Orientation)、 纹理特征(Texture Features)、闵可夫斯基维度(Minkowski Dimension)等。 ​ iii. 人数回归 该步骤的目的是将上一步提取到的特征回归到图像中的人数，回归可以是简 单的线性回归，也可以用复杂的非线性回归。常用的回归方法有:线性回归(Linear Regression)、分段线性回归(Piece-wise Linear Regression)、脊回归(Ridge Regression)、高斯过程回归(Gaussian Process Regression)等。 b) 而对于单张图像而言没有运动信息，那么人群分割就显得非常困难，因此此 类算法一般直接从整张图像或者其子区域提取特征，然后再计算图像中人群数量。 通过查询网上资料，最终确定为利用 python 以及 python-opencv 简单地实现 算法，达到人脸检测、人头检测等基本目的。 深度卷积神经网络 基于深度学习的人群分析技术，不再采用人为定义特征的方式去判断目标是 否为“人”。通过使用大量数据训练模型，计算机可以自行学习并抽象出人群的 概念，并有效提取出针对人群分析有效的特征。这种针对人群整体的分析方法有 效克服了传统的基于人的个体分析方法所无法解决的大规模复杂场景的适应性 问题，并且人数统计精确度达到 95%以上。下图为针对人群密度估计的卷积神经 网络结构图: 目前人群密度估计的深度卷积神经网络有多种，包括 single-CNN、 multi-column CNN、multi-network CNN、multi-scale CNN、adapting CNN 等。 single-CNN 采用单列神经网络估计人群密度图，但是受限于获取图片多尺度信息 而难以达到更好地效果;multi-column CNN 采用多列卷积神经网络，每列网络使 用不同尺寸的卷积核，更充分地获取图片尺度信息并且达到良好效果，此外 multi-network CNN 采用深浅两列网络以解决空间分辨率问题，但是 Multi-column/network 有两个缺点:一点是需要预训练单列网络以达到全局优化， 为端到端训练增加复杂度，另一点是引入更多的参数，消耗更大的计算资源。而 multi-scale CNN 采用单列网络+多尺度卷积核的方式，下图为 MSCNN 的神经网 络结构图: 其中每层网络分为 99、77、55、33 四种尺度卷积核，如下图所示: MSCNN 既克服图片尺度变化问题，又克服多元网络的参数过多、全局优化困难 等问题，故在本项目最终采用 MSCNN 作为本项目的核心算法。而 ACNN 充分 利用摄像头角度信息训练网络，但是由于精力有限没有进一步实践 ACNN 算法。 实际操作 ​ 语言使用python，并导入open-cv模块对图像进行处理以及MCNN和numpy等核心模块，数据集为从网络下载，并使用matlab为测试数据创建地面实况文件和创建训练和validataion集以及地面实况文件 ​ github: https://github.com/DemoMath/Density-detection","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://wudiblog.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://wudiblog.com/tags/机器学习/"},{"name":"北航","slug":"北航","permalink":"http://wudiblog.com/tags/北航/"}]},{"title":"考上北航了","slug":"考上北航了","date":"2018-09-15T08:02:12.000Z","updated":"2019-02-02T08:19:44.341Z","comments":true,"path":"2018/09/15/考上北航了/","link":"","permalink":"http://wudiblog.com/2018/09/15/考上北航了/","excerpt":"","text":"北航东门 ​ 将近一年的时间心心念念的愿望终于实现了，还记得大学离开学校的时候就对人说过，以后有机会我也要考研究生（虽然当时我的成绩差的不能再差…），最后还是下决心去尝试了，结果还不错 校内的博物馆 小时候我可是有一个开飞机，开火箭的梦想啊 天道酬勤，继续加油吧！","categories":[{"name":"北航","slug":"北航","permalink":"http://wudiblog.com/categories/北航/"}],"tags":[{"name":"北航","slug":"北航","permalink":"http://wudiblog.com/tags/北航/"},{"name":"学习","slug":"学习","permalink":"http://wudiblog.com/tags/学习/"}]},{"title":"网安5000G资源","slug":"网安5000G资源","date":"2018-06-05T17:13:07.000Z","updated":"2019-02-02T07:19:56.483Z","comments":true,"path":"2018/06/06/网安5000G资源/","link":"","permalink":"http://wudiblog.com/2018/06/06/网安5000G资源/","excerpt":"","text":"名称 链接 密码 一笔√带过入侵教程 点我查看资源 ypan 〔复仇者〕新手入门系列(7套) 点我查看资源 g1tb 2015cracer入侵入门到精通视频教程 点我查看资源 trf3 菜鸟基础(10套) 点我查看资源 2zq6 计算机网络 点我查看资源 v145 计算机网络视频教程 点我查看资源 3btd TCP_IP协议基础视频教程 点我查看资源 ta7z IP地址子网划分终极降解视频讲解（17讲） 点我查看资源 tfj4 互联网络工程技术 点我查看资源 ns1t 计算机网络原理精讲视频教程 点我查看资源 a9re 运维视频教程（14套） 点我查看资源 6qfu 宽带网络交换技术 点我查看资源 2mbs google黑客 系列 点我查看资源 rlzh 谷歌黑客语法入门视频教程 点我查看资源 uvbd Kali Linux——入侵渗透（2套） 点我查看资源 3xwn xss技术大全 点我查看资源 5uzr XSS教程系列（2套） 点我查看资源 gcrr 病毒分析视频教程 点我查看资源 3lf0 代码审计pdf 点我查看资源 yz4c 暗月2014最新PHP代码审计系列教程 点我查看资源 li4h 钓鱼站点开发系列教程 点我查看资源 5su8 幽灵逆向反汇编逆向教程12课 点我查看资源 twfh Burpsuite视频教程_2014年 点我查看资源 9bwk Burp软件教程 点我查看资源 y0jl 神器们的使用教程（8套） 点我查看资源 ie3g 靶机搭建（7套） 点我查看资源 ejfo BackTrack渗透16课 点我查看资源 s5nv BT5使用课程 点我查看资源 cu89 burpsuite 系列视频教程 点我查看资源 pjpr Metasploit教程大全 点我查看资源 q9fk webshell提权教程 点我查看资源 8ttn 菜鸟腾飞安BackTrack渗透-视频教程 点我查看资源 4ktc angelc0de原创burpsuite系列VIP培训教程 点我查看资源 o6sj 慕课网—前端开发工具SublimeTex实用技巧 点我查看资源 goz7 用工具快速建站扒站教程 点我查看资源 kd63 常涛的教程（5套） 点我查看资源 3jyh Backtrack工具教程 点我查看资源 aw4g MFC软件使用教程 点我查看资源 i0nn 黑客工具MSF系列培训教程 点我查看资源 rxbd 靶机环境 点我查看资源 sqya 戈雅渗透论坛脚本安全系列教程+工具包 点我查看资源 4gol 〔复仇者〕服务器维攻防(3套) 点我查看资源 gkjk 网络攻防（8套） 点我查看资源 rd6i 商城论坛建站（3套） 点我查看资源 2b9r 脚本相关系列 点我查看资源 uxdi 中国黑客组织脚本入侵6课 点我查看资源 47qk 『逆向免杀』（39套） 点我查看资源 wqrg 免杀教程大合集（4套） 点我查看资源 y1bt 日月神教源码免杀第一季 点我查看资源 su0r 逆向免杀（48套） 点我查看资源 v0my 上兴木马软件+教程 点我查看资源 tm9s 抓鸡远控视频+软件 点我查看资源 f8wb 刺客安全网抓鸡VIP课程 点我查看资源 07h4 2014最新实战3306端口抓鸡 点我查看资源 4qnn 完全精通DDOS软件的配置和使用 点我查看资源 qi72 逆向分析（5套） 点我查看资源 pzwu 破解软件教程（10套） 点我查看资源 5ysm 『脱壳破解』（68套） 点我查看资源 zi30 2012最新天狼星加密视频破解教程（附工具）共15个视频 点我查看资源 iicy 脱壳破解（76套） 点我查看资源 eh41 加密破解（3套） 点我查看资源 8udp 90大流5分钟教会你内网劫持 点我查看资源 j7b4 渗透教程菜鸟也能变大神 点我查看资源 ammw 〔复仇者〕高级渗透教程（10套） 点我查看资源 ika7 〔复仇者〕渗透整套教程（59套） 点我查看资源 iqw2 〔复仇者〕杂七杂八教程（40套） 点我查看资源 uk33 杀魂道长渗透教程 点我查看资源 u9cr 【9.18】黑客学院 点我查看资源 hdon 渗透 点我查看资源 bajh 多种网站入侵方法（10套） 点我查看资源 5uz7 Web渗透拿站 点我查看资源 oqil HACK80原创教程 点我查看资源 4vbi Lieker渗透系列 点我查看资源 nxz0 安全渗透测试实践初级课程 点我查看资源 i15z 暗月渗透教程第一季全套67节 点我查看资源 znkc 滴水网络第一期初级逆向培训视频[无KEY 完整版] 点我查看资源 m42s 黑客风云vip教程 点我查看资源 2cae 黑客组织pkav培训文件 点我查看资源 jl46 社工系列更新 点我查看资源 0h4z 渗透测试 点我查看资源 ajl4 渗透测试工程师 点我查看资源 a06t 渗透资料大全 点我查看资源 bcia 辛巴的教程 点我查看资源 2ifv 暗月信息安全论坛YY语音视频公开（111分钟） 点我查看资源 uyee 饭客网络渗透第一部分 点我查看资源 czcw 给日月神教做的20课教学视频 点我查看资源 objb 日月神教高级渗透课程第一季 点我查看资源 0n7n 日月神教入侵教程(21-36) 点我查看资源 3ih5 入侵资料 点我查看资源 jm45 r00ts小组培训教程 点我查看资源 pa7c 猫客渗透教程 点我查看资源 gvsw 日月神教渗透之旅课程 点我查看资源 zf08 武林黑客技术论坛远程普级入侵渗透教程 点我查看资源 7s8j YES黑客联盟小艾脚本VIP系列教程 点我查看资源 zao3 【猫客工作室】渗透资料大全 点我查看资源 yzwh 牧民VIP脚本渗透课程 点我查看资源 eifl G2soS渗透教程 点我查看资源 7shv 一期加密视频的提取教程+工具 点我查看资源 ylx3 法客论坛系列教程（4套） 点我查看资源 8wp5 饭客网黑客系列教程（13套） 点我查看资源 ief6 黑猫论坛系列教程（3套） 点我查看资源 ha6i 夜猫论坛系列教程（3套） 点我查看资源 6ofs 网络学院完整VIP系列教程（24套） 点我查看资源 56ka 外挂编程系列（20套） 点我查看资源 81bi 华夏联盟系列教程（2套） 点我查看资源 mglq 华中红客系列教程（29套） 点我查看资源 b1pe 入侵教程系列（33套） 点我查看资源 mvi3 若水论坛系列教程（4套） 点我查看资源 iagi 渗透视频教程18集 点我查看资源 8xzx 天草系列教程（7套） 点我查看资源 4l11 天都吧系列教程（5套） 点我查看资源 kf07 中国黑客组织系列教程（12套） 点我查看资源 jdup 中华隐士系列教程（4套） 点我查看资源 ibjf 暗组花指令系列教程1-4课 点我查看资源 jzrz 黑客基地VIP封包视频教程 点我查看资源 u24g 黑客命令与典型应用 视频教程 点我查看资源 hx3k 扫描探测（10套） 点我查看资源 hq6e 扫描教程大全. 点我查看资源 it83 〔复仇者〕大牛经验笔录 点我查看资源 tcbk T4ab技术小组2013入侵日站系列教程 点我查看资源 tn2u 实战小视频 点我查看资源 0tiw 2013暑假全部实战教程 点我查看资源 ieaj 无线电安全 点我查看资源 inh9 安卓逆向基础教程全套 点我查看资源 o8bn WirelessHacking3无线网络黑客攻防系列教程 点我查看资源 cjzc 免流量软件+教程 点我查看资源 5vb6 〔复仇者〕部分拿shell集 点我查看资源 io0t 提权系列 点我查看资源 a6jw 提权教程（10套） 点我查看资源 2vpt 流年VIP教程网页游戏辅助软件制作系列课程全5部分（附工具） 点我查看资源 fn4a 网吧视频教程（8套） 点我查看资源 qfs5 超级网络管理员培训教程 点我查看资源 rjeb 综合布线 点我查看资源 u6zm 网络管理员教程（25套） 点我查看资源 1p4i U盘启动盘制作及清除XP登陆密码 点我查看资源 x3g4 入侵网吧主机任意加钱教程 点我查看资源 ruzm 缓冲区溢出教程 点我查看资源 fs7p 暗组缓冲区溢出教程 点我查看资源 8agq 计算机结构（11套） 点我查看资源 0bn4 棉猴AsyncSelect模型QQ程序系列教程 点我查看资源 u5kd 无本搭建在线版qq机器人网站 点我查看资源 cx35 sqlmap注入 点我查看资源 ps75 SQL注入系列教程（6套） 点我查看资源 rin9 搜索型注入 点我查看资源 2887 0day系列大全（8套） 点我查看资源 nbbb 0day视频教程（3套） 点我查看资源 iifn 中安网培黑客入门视频教程 点我查看资源 j8wo 黑客攻防技术见招拆招视频教程 点我查看资源 toea 黑客攻防入门与进阶教程 点我查看资源 yevi WiFi密码破解教程和工具 点我查看资源 n6qf WiFi破解新手入门 点我查看资源 icjq BT5无线蹭网利器光盘版+全套工具+视频教程 点我查看资源 9xcx WIFI无线密码破解视频教程+工具制作教程 点我查看资源 01tz WIFI无线破解视频教程软件全套资料 点我查看资源 yf8g 【U盘启动】WPA2无线破解软件+视频教程 点我查看资源 ac6i 价值588无线破解视频教程 点我查看资源 t0dr WPA破解教程(BT系列) 点我查看资源 4eel 无线网络安全技术教程 点我查看资源 dd85 ASP视频教程（3套） 点我查看资源 5p4b C#_ASP.NET视频教程（99套） 点我查看资源 hr64 html视频教程（10套） 点我查看资源 yf45 javascript视频教程（6套） 点我查看资源 08gb JAVA视频教程（45套） 点我查看资源 无 SQL视频教程（3套） 点我查看资源 5ksv SQL视频教程（6套） 点我查看资源 uqhj 微信开发视频教程（3套） 点我查看资源 c9j1 易语言视频教程（24套） 点我查看资源 2af7 C语言视频教程（110套） 点我查看资源 5csn delphi视频教程 点我查看资源 mhog iphone开发视频教程（56套） 点我查看资源 qznh jsp视频教程 点我查看资源 raml python视频教程（19套） 点我查看资源 rb4v VB视频教程（3套） 点我查看资源 3uzq Android编程（40套） 点我查看资源 高级Windows程序设计 点我查看资源 imr1 汇编教程（7套） 点我查看资源 mh4l Dos教程 点我查看资源 v183 编程回忆录（7套） 点我查看资源 vg14 Web前端开发（15套） 点我查看资源 tzb2 linux教程大全（8套） 点我查看资源 5yzp 零基础入门学习汇编语言_78_小甲鱼 点我查看资源 1rmx [暗月论坛收集]python灰帽编程 点我查看资源 oobp MySQL入门到全面精通视频教程 全40讲 点我查看资源 myl9 PHP100系列教程 点我查看资源 g9rr SQL SEVER05 08 12教程（3套） 点我查看资源 saxq 网游编程教程 点我查看资源 bpda 驱动系列教程（6套） 点我查看资源 kpok 精易论坛易语言核心支持库全套教程 点我查看资源 w66k 牛B代码论坛PE格式学习视频教程（29课） 点我查看资源 sjnv 阳光学院数据结构[24课] 点我查看资源 sayu 病毒（电脑上不要双击打开） 点我查看资源 2mvg 大学吧 点我查看资源 n71u Cisco思科教程 点我查看资源 rnce 安全教程系列（6套） 点我查看资源 fbxf 猎豹网校教程系列（2套） 点我查看资源 8bhd 安全防御（5套） 点我查看资源 sbfa Mayter_2014年大型Web安全培训课程 点我查看资源 aipi 清华大学计算机学习资源(20套) 点我查看资源 vi76 吉林大学计算机远程教程（13套） 点我查看资源 9i47 其它大学计算机课程（5套） 点我查看资源 qulv 上海交通大学计算机专业课程(45套) 点我查看资源 1d0d 电脑维修教程（13套） 点我查看资源 dxpq Apache服务深入解析系列视频教程 点我查看资源 zwv1 电脑维修（4套） 点我查看资源 4mi9 新网站SEO五步优化法原版无KEY 点我查看资源 a52k 黑客小技巧 点我查看资源 c9s6 利用路由器后台查看宽带账号密码 点我查看资源 kxiv 隐藏创建用户教程 点我查看资源 87ap 电脑技术类教程（3套） 点我查看资源 baom 图文教程PIN进度保存和修改方法 点我查看资源 1cgk 雨荷数据恢复教程1-63集 点我查看资源 u8o8 最新远程控制别人电脑比QQ更快 点我查看资源 gdnd 经典万能密码进后台 点我查看资源 lc68 图书教程 点我查看资源 1gh5 黑客新手综合书藉 点我查看资源 28xv linuxPDF教程 点我查看资源 yyti 学员渗透录PDF 点我查看资源 vyf8 高手入侵总结文档 点我查看资源 y68q 2015年最新教程集 点我查看资源 yz1u 以下为软件链接 文件名 链接 提取密码 cracer配套软件 点我查看资源 dkfe 百度云网盘破解版（点击试用加速，永久加速） 点我查看资源 w27h 邪影渗透小组工具包2016最新版 V2.3 点我查看资源 jkns 腾讯QQ5.5(11447)木头查IP精简版 点我查看资源 wm6q 2009qq获得IP 点我查看资源 zau8 操作系统 点我查看资源 amzt 虚拟机 点我查看资源 qe29 2015-K8飞刀 点我查看资源 xc1b Layer子域名挖掘机3.1 点我查看资源 l3xf [最新版]邪影渗透小组工具包 点我查看资源 fbe0 安全盒子旁注工具_jar版 点我查看资源 oybc 提权区域 点我查看资源 hiyy hydra-7.3-windows 点我查看资源 oa49 swf播放器 点我查看资源 2ojz 钓鱼网站源码 点我查看资源 5fm0 网站源码 点我查看资源 6uxt VirtualBox虚拟机 Portable v4.2.18.88780 中文绿色便携版 32位_XP85 点我查看资源 pch0 安卓远控5.0重启上线版本（慎用，我没测试过） 点我查看资源 ops5 传马工具 点我查看资源 e1i6 最新木马 点我查看资源 q8oe 2015穿盾 点我查看资源 vhmd 官方大灰狼远程管理V8.96 更新免杀 点我查看资源 9gs9 木马源码 点我查看资源 69ha 抓肉鸡软件 点我查看资源 s6ln 微信朋友圈支付宝截图制作软件 点我查看资源 riqq 暴力宣传软件生成器 点我查看资源 mjvp 录屏专家破解版 点我查看资源 6e6y 营业执照生成器可用于 微博认证 点我查看资源 untp 优酷会员电影免费看 点我查看资源 3p46 电脑加密软件破解软件 点我查看资源 76pe 手机渗透系统 点我查看资源 iunc 远控+手机端 点我查看资源 wka2 裤子收藏 点我查看资源 7wpj 4899抓鸡+网吧i8desk控制台挂马 点我查看资源 4qgi appscan9.02 点我查看资源 u9ov 类库 点我查看资源 rqdl 复愁者渗透工具包 点我查看资源 nmkk 比较全的提权工具 点我查看资源 af79 天镜脆弱性扫描与管理系统 点我查看资源 x4to 海伦匿名者U盘文件 点我查看资源 r31i 渗透系统 点我查看资源 zy43 qq2013源码 点我查看资源 7il1 墨白免杀远控 点我查看资源 bqub 地球上最小的极速浏览器 点我查看资源 crdr kali-linux系统 点我查看资源 ik7g md5彩虹表 点我查看资源 j3k5 WIFEI暴破 点我查看资源 rpa2 WPA-WPA2无线网络 点我查看资源 8psu 安卓逆向工具 点我查看资源 euff 加密狗破解 点我查看资源 cu3r 漏洞收藏 点我查看资源 qspe 录屏工具 点我查看资源 cmmr 免杀源码 点我查看资源 ftxt 渗透系统 点我查看资源 79u1 提权exp收录 点我查看资源 3b2m 天天酷跑精灵帮帮 点我查看资源 ihdm 易语言黑客软件源码打包 点我查看资源 q33y 字典 点我查看资源 ter8 AppScan 8.7 点我查看资源 ezlr Bat转Exe格式 点我查看资源 9ugh DarkDuke远控2.0 点我查看资源 vnd0 FTP密码爆破 点我查看资源 87k3 phpddos攻击器 点我查看资源 tdja Seay webshell查杀工具 C#版源码 点我查看资源 avbz 超给力密码字典集合 点我查看资源 ybwy WEB旁注爬虫 点我查看资源 x16f 龙卷风DDOS 无需肉鸡 利用CC代理IP攻击 点我查看资源 rkta 内网装逼套装 点我查看资源 7c8p 强DNS攻击器（汉化版） 点我查看资源 6x9k 突破ARP防火墙，局域网限速软件SKiller 点我查看资源 m3gb 万象一键加钱 点我查看资源 5u4s 网页格式离线工具包 点我查看资源 w79j 无线破解手机软件 点我查看资源 u9kl 无需进路由器，就能映射端口的工具软件 点我查看资源 x1ag 一键系统还原，一键备份系统，一键重装系统 点我查看资源 d3u6 用OD修改软件标题 点我查看资源 vchm 源码小偷 点我查看资源 lirw 中国寒龙低轨道粒子炮，汉化版，含源码 点我查看资源 2vis 终身免费邮件群发器V3.2 点我查看资源 anra 最新全国ip段 点我查看资源 93mm VM虚拟机9.0.2最新版+汉化+注册机 点我查看资源 ys12 各种功能的工具包 点我查看资源 w4m4 安卓渗透工具 点我查看资源 1jc1 黑客实用小软件（100多） 点我查看资源 cams 其它源码 点我查看资源 f2wf","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://wudiblog.com/categories/网络安全/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://wudiblog.com/tags/资源/"},{"name":"网安","slug":"网安","permalink":"http://wudiblog.com/tags/网安/"}]},{"title":"Windows环境以太坊私链搭建","slug":"Windows环境以太坊私链搭建","date":"2018-05-04T03:10:22.000Z","updated":"2019-02-02T07:16:58.545Z","comments":true,"path":"2018/05/04/Windows环境以太坊私链搭建/","link":"","permalink":"http://wudiblog.com/2018/05/04/Windows环境以太坊私链搭建/","excerpt":"","text":"做以下准备： win10系统，64位 以太坊钱包 以太坊geth客户端 ​ geth 和 钱包可以到ethfans.org的资料库里下载，那里提供国内镜像和官网地址。 ​ 钱包工具：https://ethfans.org/wikis/Ethereum-Wallet-Mirror ​ geth :https://ethfans.org/wikis/Ethereum-Geth-Mirror 创建创世块文件 genesis.json 1234567891011121314151617&#123; \"config\": &#123; \"chainId\": 15, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"alloc\" : &#123;&#125;, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x2000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\"&#125; 字段名 含义 nonce nonce就是一个64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。 difficulty 设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度 alloc 用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。 coinbase 矿工的账号，随便填 timestamp 设置创世块的时间戳 parentHash 上一个区块的hash值，因为是创世块，所以这个值是0 extraData 附加信息，随便填，可以填你的个性信息 gasLimit 该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。 mixhash 与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。. 初始化区块链 1geth --identity \"PICCetherum\" --rpc --rpccorsdomain \"*\" --datadir \"./data\" --port \"30303\" --rpcapi \"db,eth,net,web3\" --networkid 95518 console 创建用户 1personal.newAccount() 启动钱包可视化软件 1jar -xvf 迭代9需求.zip","categories":[{"name":"区块链","slug":"区块链","permalink":"http://wudiblog.com/categories/区块链/"}],"tags":[{"name":"虚拟货币","slug":"虚拟货币","permalink":"http://wudiblog.com/tags/虚拟货币/"},{"name":"以太坊","slug":"以太坊","permalink":"http://wudiblog.com/tags/以太坊/"},{"name":"区块链","slug":"区块链","permalink":"http://wudiblog.com/tags/区块链/"}]},{"title":"Linux网络命令","slug":"Linux网络命令","date":"2017-01-13T15:02:09.000Z","updated":"2019-02-02T05:54:00.761Z","comments":true,"path":"2017/01/13/Linux网络命令/","link":"","permalink":"http://wudiblog.com/2017/01/13/Linux网络命令/","excerpt":"","text":"ifconfig： 查看与配置网络状态命令 、 ifup/ifdown + 网卡名： 启用/禁用网卡 netstat选项（网络状态查询）： -t：列出TCP协议端口 -u：列出UDP协议端口 -n：不使用域名与服务名，而使用IP地址和端口号 -l：仅列出在监听状态网络服务 -a：列出所有","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/tags/计算机网络/"},{"name":"Linux","slug":"Linux","permalink":"http://wudiblog.com/tags/Linux/"}]},{"title":"网关作用以及讲解","slug":"网关作用以及讲解","date":"2017-01-12T06:13:57.000Z","updated":"2019-02-02T06:39:43.620Z","comments":true,"path":"2017/01/12/网关作用以及讲解/","link":"","permalink":"http://wudiblog.com/2017/01/12/网关作用以及讲解/","excerpt":"","text":"概念： 网关（Gateway）又称网间连接器，协议转换器 网关在网络层以上实现网络互联，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互联 网管既可以用于广域网互联，也可以用于局域网互联。 网关是一种充当转换重任的服务器或路由器 示意图：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/tags/计算机网络/"},{"name":"网关","slug":"网关","permalink":"http://wudiblog.com/tags/网关/"}]},{"title":"DNS作用以及讲解","slug":"DNS作用以及讲解","date":"2017-01-11T17:14:00.000Z","updated":"2019-02-02T06:51:10.254Z","comments":true,"path":"2017/01/12/DNS作用以及讲解/","link":"","permalink":"http://wudiblog.com/2017/01/12/DNS作用以及讲解/","excerpt":"","text":"不配置DNS是不能访问互联网的 Domain Name System的缩写，域名系统的缩写，又叫名称解析 名称解析概述 在互联网中，通过IP地址来进行通信 IP地址用数字表示，记忆起来比较困难 人对域名更加敏感 在DNS出现之前，我们有hosts文件（静态IP和域名对应），优先级比DNS更高 从Hosts文件到DNS 早期Hosts文件解析域名 名称解析效能下降 主机维护困难 DNS服务 层次性 分布式 DNS服务的作用 将域名解析为IP地址 客户机向DNS服务器发送域名查询请求 DNS服务器告知客户机Web服务器的IP地址 客户机与Web服务器通信 域名空间结构 ​ 根域 顶级域（域名分配组织ISO分配） 组织域（gov政府，com商业，edu教育，org民间组织，net网络服务，mil军事） 国家或地区域(cn中国，hk香港，jp日本，uk英国，au澳大利亚) 二级域 主机名 DNS查询过程 DNS查询类型 从查询方式上区分 递归查询：要么做出查询成功响应，要么作出查询失败的响应，一般客户机和服务器之间属于递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交给客户机 迭代查询：服务器收到一次迭代查询回复一次结果，这个结果不一定是目标IP与域名的映射关系，也可以是其他DNS服务器的地址 从查询内容上区分 正向查询由域名查找IP地址 反向查询由IP地址查找域名","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/categories/计算机网络/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"http://wudiblog.com/tags/DNS/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/tags/计算机网络/"}]},{"title":"SSH协议远程登录","slug":"SSH协议远程登录","date":"2017-01-03T03:02:09.000Z","updated":"2019-02-02T07:08:16.499Z","comments":true,"path":"2017/01/03/SSH协议远程登录/","link":"","permalink":"http://wudiblog.com/2017/01/03/SSH协议远程登录/","excerpt":"","text":"SSH协议原理 对称加密算法： 采用单钥密码系统的加密方法，同一个秘钥可以同时用作信息的加密和解密，这种加密方法成为对称加密，也称为单秘钥加密 非对称加密算法： 又名“公开秘钥加密算法”，非对称加密算法需要两个秘钥：公开秘钥和私有秘钥 ​ ssh 用户名@ip 远程登录指定Linux服务器 ​ scp [-r] 用户名@ip：文件路径 本地路径 下载文件 ​ scp [-r] 本地文件 用户名@ip：上传路径 上传文件 SecureCRT远程管理工具 ​ windows平台管理linux服务器，收费 Xshell工具 ​ windows平台管理linux服务器，免费","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/tags/计算机网络/"},{"name":"SSH","slug":"SSH","permalink":"http://wudiblog.com/tags/SSH/"}]},{"title":"实现WebView中网页与App的Activity跳转","slug":"实现WebView中网页与App的Activity跳转","date":"2016-12-02T15:58:02.000Z","updated":"2019-02-02T07:08:06.255Z","comments":true,"path":"2016/12/02/实现WebView中网页与App的Activity跳转/","link":"","permalink":"http://wudiblog.com/2016/12/02/实现WebView中网页与App的Activity跳转/","excerpt":"","text":"介绍三种实现方式: 通过JS来实现 通过scheme来实现(不支持webview的重定向) 通过webview的重定向（setWebViewClient（WebView view,String url）{})方法中对url判断，隐式意图打开Activity 1.通过JS 只需要三个步骤: WebView开启JavaScript脚本执行。 WebView设置供JavaScript调用的交互接口。 客户端和网页端编写调用对方的代码。 2.通过scheme（Deep Linking深度链接) 2.1在html中，设置链接 123456789&lt;a href=\"myscheme://host：8080/path/?action=com.example.wudi.webviewdemo.baginfo&amp;id=123\"&gt; Take a QR code &lt;/a&gt;&lt;!--bagin 下面介绍各个部分: \"myscheme\":scheme \"host\":host主机 \"8080\":post端口号 \"path\":path路径 \"action\"=com.example.wudi.webviewdemo.baginfo&amp;id=123:params参数 --&gt; 2.2然后我们在清单文件中需要给要打开的activity设置intent-filter的scheme(scheme:计划；组合；体制；诡计)，其中scheme必须和链接中scheme保持一致,host可写可不写，自行忽略 1234567891011121314151617181920&lt;activity android:name=\".DemoActivity\"&gt; &lt;!— URI Scheme方式 -—&gt; &lt;intent-filter&gt; &lt;data android:scheme=\"myscheme\" /&gt; &lt;data android:host=\"host\"/&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt; &lt;!--&lt;data android:host=\"\" android:mimeType=\"\" android:path=\"\" android:pathPattern=\"\" android:pathPrefix=\"\" android:port=\"\" android:scheme=\"\" android:ssp=\"\" android:sspPattern=\"\" android:sspPrefix=\"\"/&gt;--&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 2.3 这样我们在要打开的activity中获取参数: 1234567Intent intent = getIntent();Log.e(\"TAG\", \"scheme:\" + intent.getScheme());Uri uri = intent.getData();if (uri != null) &#123; Log.e(\"TAG\", \"id:\" + uri.getQueryParamter(\"id\")); Log.e(\"TAG\", \"action:\" + uri.getQueryParamter(\"name\"));&#125; 需要注意的是：这种方式不支持webview的重定向操作，如果你对webview设置了重定向，那么就会返回:ERR_UNKNOWN_URL_SCHEME(点击链接查看老外咋解决，前提要翻墙，其实他们也没解决)。 3.通过隐式意图 如果我们不想写js，又想要对webview进行重定向（大多数android开发都需要，因为要适配),那么就可以通过隐式意图 基本上和第二种方式相同： 3.1 在html中: 1&lt;a href=\"android://?action=com.example.wudi.webviewdemo.baginfo&amp;id=123\"&gt; Take a QR code &lt;/a&gt; 3.2 与第二种方式不同的是：当中的链接是自己自定义的，如果你够聪明，就能拼写出优秀的uri，就像上边我拼的，因为项目中，需要和ios同步开发（ios用的LMBIOS），所以我定义了android来作为我的区分。 下边我们需要在清单文件中给activity设置action和category 1234567&lt;activity android:name=\".DemoActivity\"&gt; &lt;!-- &lt;!— URI Scheme方式 -—&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.wudi.webviewdemo.baginfo\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 3.3 可以发现我设置的action和上边链接中action参数一致，下边就需要在webview重定向时，进行判断了 1234567891011121314151617181920webview.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; // TODO Auto-generated method stub //返回值是true的时候控制去WebView打开，为false调用系统浏览器或第三方浏览器 if (url.startsWith(\"android\")) &#123; Uri uri = Uri.parse(url); String host = uri.getHost(); String action = uri.getQueryParameter(\"action\"); String id = uri.getQueryParameter(\"id\"); Intent intent = new Intent(); intent.setAction(action); intent.putExtra(\"id\",id); startActivity(intent); &#125; else &#123; view.loadUrl(url); &#125; return true; &#125;&#125;); 可以看到，我的链接拼接方式可以直接把url转成uri，并获取参数，打开activity","categories":[{"name":"移动端","slug":"移动端","permalink":"http://wudiblog.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://wudiblog.com/tags/Android/"},{"name":"WebView","slug":"WebView","permalink":"http://wudiblog.com/tags/WebView/"}]},{"title":"子网掩码讲解","slug":"子网掩码讲解","date":"2016-09-20T05:43:57.000Z","updated":"2019-02-02T06:51:22.064Z","comments":true,"path":"2016/09/20/子网掩码讲解/","link":"","permalink":"http://wudiblog.com/2016/09/20/子网掩码讲解/","excerpt":"","text":"ip和子网掩码不能单独使用，必须一起使用（不能分开查看，要一起查看） 标准子网掩码：255.0.0.0 255.255.0.0 255.255.255.0 表示对应的数变化就是不同网段，需要路由器才能相互访问，其他的变化没关系，还是同一个网段 A类IP： B类IP： C类IP： 变长子网掩码及子网规划:","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/tags/计算机网络/"},{"name":"子网掩码","slug":"子网掩码","permalink":"http://wudiblog.com/tags/子网掩码/"}]},{"title":"端口讲解","slug":"端口讲解","date":"2016-08-17T06:13:57.000Z","updated":"2019-02-02T06:51:36.482Z","comments":true,"path":"2016/08/17/端口讲解/","link":"","permalink":"http://wudiblog.com/2016/08/17/端口讲解/","excerpt":"","text":"在传输层确定端口号 通过ip能确定对方服务器位置，服务器上开启了一些服务，不同服务有不同的端口号，端口号就是为了确定目标服务器相应的服务 端口号 2的16次方 0 - 65535 TCP协议包头： UDP协议包头： 常见端口号： FTP（文件传输协议）端口号：20 21 SSH（安全shell协议）：端口号 22 telnet（远程登录协议）：端口号 23（禁用，明文传输） DNS（域名系统）：端口号53 http（超文本传输协议）：端口号80 SMTP（简单邮件传输协议）：端口号25 POP3（邮局协议3代）：端口号 110 查看本机启用的端口命令： netstat -an ​ -a：查看所有连接和监听端口 ​ -n：显示IP地址和端口号，而不显示域名和服务名","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/tags/计算机网络/"},{"name":"端口","slug":"端口","permalink":"http://wudiblog.com/tags/端口/"}]},{"title":"IP地址详解","slug":"IP地址详解","date":"2016-07-17T03:54:57.000Z","updated":"2019-02-02T06:50:57.024Z","comments":true,"path":"2016/07/17/IP地址详解/","link":"","permalink":"http://wudiblog.com/2016/07/17/IP地址详解/","excerpt":"","text":"IP包头： IP地址： 00000000.00000000.00000000.00000000 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 ​ 换算成为： ​ 0.0.0.0 ​ 255.255.255.255 IP地址分类：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/tags/计算机网络/"},{"name":"IP","slug":"IP","permalink":"http://wudiblog.com/tags/IP/"}]},{"title":"TCP/IP四层模型","slug":"TCP-IP四层模型","date":"2016-06-29T03:54:57.000Z","updated":"2019-02-02T06:54:22.442Z","comments":true,"path":"2016/06/29/TCP-IP四层模型/","link":"","permalink":"http://wudiblog.com/2016/06/29/TCP-IP四层模型/","excerpt":"","text":"TCP/IP模型与OSI参考模型的对应关系： 数据封装的过程： tcp/ip模型与osi模型的比较： 共同点： osi参考模型和tcp/ip参考模型都采用了层次结构的概念 都能提供面向连接和无连接两种通信服务机制 不同点： 前者是七层模型，后者是四层结构 对可靠性要求不同（后者更高） osi模型是在协议开发前设计的，具有通用性，tcp/ip是先有协议然后建立模型，不适用于非tcp/ip网络 实际市场应用不同（osi是理论上的模型，并没有成熟的产品，而tcp/ip已经成为“实际上的国际标准”）","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/tags/计算机网络/"},{"name":"OSI","slug":"OSI","permalink":"http://wudiblog.com/tags/OSI/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://wudiblog.com/tags/TCP-IP/"}]},{"title":"ISO/OSI七层模型","slug":"ISO-OSI七层模型","date":"2016-05-14T01:54:57.000Z","updated":"2019-02-02T06:57:52.874Z","comments":true,"path":"2016/05/14/ISO-OSI七层模型/","link":"","permalink":"http://wudiblog.com/2016/05/14/ISO-OSI七层模型/","excerpt":"","text":"iso：国际标准化组织 osi：开放系统互联模型 是TCP/IP四层模型的基础 从低到高依次： ​ 物理层 数据链路层 网络层 传输层（下四层实际传输） 会话层 表示层 应用层（上三层给用户服务） ​ 物理层：传输单位比特，真正的数据传输 ​ 数据链路层：传输单位帧，这里边包含MAC地址（物理地址，计算机网卡的硬件地址） ​ 网络层：报文，这里边包含IP地址（逻辑地址） ​ 传输层：数据段 TPDU（传输协议传输协议） ​ 会话层：SPDU(会话协议传输地址) ​ 表示层：PPDU（表示协议传输地址） ​ 应用层：APDU（应用协议传输地址） 七层模型：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wudiblog.com/tags/计算机网络/"},{"name":"ISO","slug":"ISO","permalink":"http://wudiblog.com/tags/ISO/"},{"name":"OSI","slug":"OSI","permalink":"http://wudiblog.com/tags/OSI/"}]},{"title":"Git初学使用","slug":"git初学使用","date":"2016-03-02T04:22:11.000Z","updated":"2019-02-02T07:25:56.975Z","comments":false,"path":"2016/03/02/git初学使用/","link":"","permalink":"http://wudiblog.com/2016/03/02/git初学使用/","excerpt":"","text":"记忆账号密码 1git config --global credential.helper store 配置全局信息 配置全局的用户名、邮箱信息，作为提交人信息 1git config --global user.name “name\" 1git config --global user.email \"email” 用户密码输错的话windows解决办法 ​ 控制面板-用户账户-管理你的凭据-git 保存的用户信息在普通凭据列表里-修改-完成 克隆 仓库 1git clone 地址 拉代码 1git pull origin master 提交、推送代码 12345git add -A 做了修改要先写这个命令git commit -m \"提交的信息\" git push origin master 推送代码到远程 master是分支名****重要**** 以后每次提交代码，要先拉取代码，整个流程即add-commit-pull-push,保证远程代码不要有冲突，有冲突在本地修改，再次add-commit-pull-push 分支相关 123456git branch 查看本地所有分支git branch -a 查看本地和远程所有分支git checkout 分支名 切换到某个分支git checkout -b 分支名 创建分支并切换到该分支git rm -r --cached .","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://wudiblog.com/categories/版本控制/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://wudiblog.com/tags/Git/"},{"name":"版本管理","slug":"版本管理","permalink":"http://wudiblog.com/tags/版本管理/"}]}]}